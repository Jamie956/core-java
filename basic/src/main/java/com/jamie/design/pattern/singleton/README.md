# 单例模式

定义：在当前进程中，通过单例模式创建的类有且只有一个实例



特点：

- 在Java应用中，单例模式能保证在一个JVM中，该对象只有一个实例存在
- 构造器必须是私有的，外部类无法通过调用构造器方法创建该实例
- 没有公开的set方法，外部类无法调用set方法创建该实例
- 提供一个公开的get方法获取唯一的这个实例



好处

- 某些类创建比较频繁，对于一些大型的对象，这是一笔很大的系统开销
- 省去了new操作符，降低了系统内存的使用频率，减轻GC压力
- 系统中某些类，如spring里的controller，控制着处理流程，如果该类可以创建多个的话，系统完全乱了
- 避免了对资源的重复占用



**为什么不用静态方法而用单例模式**？

两者其实都能实现我们加载的最终目的，但是他们一个是基于对象，一个是面向对象的，就像我们不面向对象也能解决问题一样，面向对象的代码提供一个更好的编程思想。

如果一个方法和他所在类的实例对象无关，那么它就应该是静态的，反之他就应该是非静态的。如果我们确实应该使用非静态的方法，但是在创建类时又确实只需要维护一份实例时，就需要用单例模式了。



## 饿汉式

初始化时创建



- 创建私有静态变量的单例对象
- 构造方法私有，不允许外部构造
- 提供获取实例的静态方法，返回静态变量



## 懒汉式

使用时创建



### 线程不安全版本

- 定义私有静态变量的单例（未创建）
- 私有构造，不允许外部实例化
- 静态方法获取实例，实例不存在时创建。方法无锁会有线程安全问题，导致创建了多个实例



### 加锁版本

- 定义私有静态变量的单例（未创建）
- 私有构造，不允许外部实例化
- 静态方法获取实例，实例不存在时创建，与线程不安全不同的是，方法加了锁保证线程安全，但降低了效率



### 双检锁版本

- 定义私有静态变量的单例（未创建）
- 私有构造，不允许外部实例化
- 静态方法获取实例，实例不存在时创建。是加锁版的升级，先判断实例非空再上锁，再判空，而不是一开始就上锁
- `INSTANCE = new LazySingleton3()`对象的创建和赋值是两个指令，会有指令重排问题



### 实例内存可见版本

- 定义私有静态变量的单例（未创建）
- 私有构造，不允许外部实例化
- 静态方法获取实例，实例不存在时创建。解决双检锁的指令重排，实例变量使用`volatile`保证变量的内存可见性，保证各CPU缓存里的变量保持一致。



### 静态内部类版本

- 构造函数私有化，防止外部创建
- 定义静态内部类，创建它的静态私有变量单例
- 定义静态方法，获取实例，也就是访问静态内部类的静态变量
- JVM 保证线程安全



## 单例最佳实践

枚举

